---
layout: post
title:  "Android 6.0 JNI uses long to store pointer address"
date:   2017-07-19 22:47:00 +0800
categories: aosp
---

Android 6.0 JNI uses long to store pointer address, which Android 5.0 JNI use int to store pointer address. In Android 5.0, some system servers use long to store pointer address of native object, which is stored as int. If system servers want to use pass it to native methods, it will force cast long parameter to int, for example `mPtr` in `InputManagerService.java`. But in Android 6.0, JNI uses long to store pointer address, and system servers also uses long to store pointer address of native object, for example `mPtr` in `InputManagerService.java`. 

Normally, if we fouces on the difference, there is no problem. But I have encountered a weird problem, when I tried to cherry-pick one feature from Android 5.0 to Android 6.0 , wrote with JNI. The feature wrote in Android 5.0 with JNI force casts long parameter which stores pointer address in system server to int when invoke native methods, but when I cherry-picked it to Android 6.0, the system crashed in some occassion, because of the pointer address has changed when force be casted. WTF.
